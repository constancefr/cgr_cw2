#ifndef SCENE_H
#define SCENE_H

#include <vector>
#include <memory>
#include <string>
#include "vector3.h"
#include "ray.h"
#include "shape.h"
#include "sphere.h"
#include "triangle.h"
#include "cylinder.h"
#include "libs/json.hpp"

enum class LightType {
    Point,
    Area
};

struct Light {
    LightType type; // point or area
    vector3 position; // centre of light source
    vector3 intensity;
    vector3 u; // u-axis for area light
    vector3 v; // v-axis for area light
    double width;
    double height;
};

enum class RenderMode {
        Binary,
        BlinnPhong
};

class Scene {
public:
    RenderMode render_mode;
    vector3 backgroundcolor;
    std::vector<std::shared_ptr<Shape>> shapes;
    std::vector<Light> lights;
    std::shared_ptr<BVH> bvh;
    bool use_bvh = false;
    bool enable_antialiasing = false;

    RenderMode parse_render_mode(const std::string& mode_str) {
        if (mode_str == "binary") return RenderMode::Binary;
        return RenderMode::BlinnPhong;
        // throw std::invalid_argument("Unknown render mode: " + mode_str);
    }

    void set_render_mode(RenderMode mode) {
        render_mode = mode;
    }

    Scene(const vector3& background_color) : backgroundcolor(background_color) {}

    // Load scene from JSON configuration
    void load_from_json(const nlohmann::json& scene_json);

    void add_shape(const std::shared_ptr<Shape>& shape) {
        shapes.push_back(shape);
    }

    void add_light(const Light& light) {
        lights.push_back(light);
    }

    // vector3 shade(const ray& r, const vector3& hit_point, const vector3& normal, const Shape& hit_shape, const Material& material, int depth) const;
    vector3 shade(const ray& r, const vector3& hit_point, const vector3& normal, const Shape& hit_shape, int depth) const;
    
    vector3 shade_binary(const ray& r, const vector3& hit_point, const vector3& normal, const Shape& hit_shape, int depth) const;

    // vector3 shade_blinn_phong(const ray& r, const vector3& hit_point, const vector3& normal, const Shape& hit_shape, const Material& material, int depth) const;
    vector3 shade_blinn_phong(const ray& r, const vector3& hit_point, const vector3& normal, const Shape& hit_shape, int depth) const;

    vector3 compute_blinn_phong(
        const vector3& point,
        const vector3& normal,
        const vector3& view_dir,
        const Material& material,
        const Shape& shape
    ) const;

    vector3 compute_reflection(
        const ray& r,
        const vector3& hit_point,
        const vector3& normal,
        const Material& material,
        int depth
    ) const;

    vector3 compute_refracted_direction(
        const vector3& incident,
        const vector3& normal,
        double ior_in,
        double ior_out
    ) const;

    // BVH
    void build_bvh() {
        if (use_bvh) {
            bvh = std::make_shared<BVH>(shapes);
        }
    }

    bool intersects(const ray& r, double& t_hit, std::shared_ptr<Shape>& hit_shape, double max_t) const {
        if (use_bvh) {
            return bvh->intersects(r, t_hit, hit_shape, max_t);
        }
        // Brute force: iterate over all shapes in the scene and checks for intersections with the given ray.
        return brute_force_intersects(r, t_hit, hit_shape, max_t);
    }

    bool brute_force_intersects(const ray& r, double& t_hit, std::shared_ptr<Shape>& hit_shape, double max_t) const;
    // bool intersects(const ray& r, double& t_hit, std::shared_ptr<Shape>& hit_shape, double max_t) const;


};

#endif
