-- COPILOT -- 
Area Light Sampling:

For area lights, generate multiple sample points on the light's surface using random values for u and v.
Calculate the direction to each sample point and the halfway vector.
Compute the diffuse and specular contributions for each sample point.
Accumulate the contributions and average them by dividing by the number of samples.
Point Light:

For point lights, compute the lighting contributions as before.

vector3 Scene::compute_blinn_phong(
    const vector3& point,
    const vector3& normal,          // Surface normal at the point
    const vector3& view_dir,        // Direction from point to camera
    const Material& material,
    const Shape& shape
) const {
    vector3 color(0.0, 0.0, 0.0);

    auto uv = shape.get_uv(point);

    vector3 texture_color = material.texture
        ? material.texture->get_color_at_uv(uv.first, uv.second)
        : material.diffusecolor; // Default to diffuse color if no texture is present

    for (const auto& light : lights) {
        if (light.type == LightType::Area) {
            // Area light sampling
            int num_samples = 16; // Number of samples for area light
            vector3 area_light_color(0.0, 0.0, 0.0);

            for (int i = 0; i < num_samples; ++i) {
                // Generate random sample point on the area light
                double u = static_cast<double>(rand()) / RAND_MAX;
                double v = static_cast<double>(rand()) / RAND_MAX;
                vector3 sample_point = light.position + u * light.u * light.width + v * light.v * light.height;

                // Calculate vectors
                vector3 light_dir = (sample_point - point).unit(); // Direction to the sample point
                vector3 half_vector = (view_dir + light_dir).unit(); // Halfway vector

                // Diffuse contribution
                double diff = std::max(0.0, normal.dot(light_dir));
                vector3 diffuse = material.kd * diff * texture_color * light.intensity;

                // Specular contribution
                double spec = std::pow(std::max(0.0, normal.dot(half_vector)), material.specularexponent);
                vector3 specular = material.ks * spec * material.specularcolor * light.intensity;

                // Accumulate contributions
                area_light_color += diffuse + specular;
            }

            // Average the contributions from all samples
            area_light_color /= num_samples;
            color += area_light_color;
        } else {
            // Point light
            vector3 light_dir = (light.position - point).unit(); // Direction to the light
            vector3 half_vector = (view_dir + light_dir).unit(); // Halfway vector

            // Diffuse contribution
            double diff = std::max(0.0, normal.dot(light_dir));
            vector3 diffuse = material.kd * diff * texture_color * light.intensity;

            // Specular contribution
            double spec = std::pow(std::max(0.0, normal.dot(half_vector)), material.specularexponent);
            vector3 specular = material.ks * spec * material.specularcolor * light.intensity;

            // Accumulate contributions
            color += diffuse + specular;
        }
    }

    return color;
}

-----------------------------------------------------------------------------------------------------------------

-- CHATGPT -- (better?)

vector3 Scene::sample_area_light(const Light& light) const {
    // Sample a random point on the surface of the area light
    double rand_u = static_cast<double>(rand()) / RAND_MAX; // Random value in [0, 1]
    double rand_v = static_cast<double>(rand()) / RAND_MAX; // Random value in [0, 1]
    vector3 sampled_point = light.position +
                            (rand_u - 0.5) * light.u * light.width +
                            (rand_v - 0.5) * light.v * light.height;
    return sampled_point;
}

double Scene::compute_shadow_factor(const vector3& point, const vector3& light_sample) const {
    vector3 light_dir = (light_sample - point).unit();
    ray shadow_ray(point + light_dir * 0.001, light_dir); // Offset to avoid self-intersection

    double t_hit;
    std::shared_ptr<Shape> hit_shape;
    if (intersects(shadow_ray, t_hit, hit_shape, (light_sample - point).length())) {
        return 0.0; // In shadow
    }
    return 1.0; // Fully lit
}

vector3 Scene::compute_blinn_phong(
    const vector3& point,
    const vector3& normal,
    const vector3& view_dir,
    const Material& material,
    const Shape& shape
) const {
    vector3 color(0.0, 0.0, 0.0);

    auto uv = shape.get_uv(point);

    vector3 texture_color = material.texture
        ? material.texture->get_color_at_uv(uv.first, uv.second)
        : material.diffusecolor; // Default to diffuse color if no texture is present

    for (const auto& light : lights) {
        if (light.type == LightType::Point) {
            vector3 light_dir = (light.position - point).unit();
            vector3 half_vector = (view_dir + light_dir).unit();

            // Diffuse contribution
            double diff = std::max(0.0, normal.dot(light_dir));
            vector3 diffuse = material.kd * diff * texture_color * light.intensity;

            // Specular contribution
            double spec = std::pow(std::max(0.0, normal.dot(half_vector)), material.specularexponent);
            vector3 specular = material.ks * spec * material.specularcolor * light.intensity;

            // Shadow factor
            double shadow_factor = compute_shadow_factor(point, light.position);

            // Accumulate contributions
            color += (diffuse + specular) * shadow_factor;

        } else if (light.type == LightType::Area) {
            int sample_count = 16; // Number of samples for area light
            vector3 light_contribution(0.0, 0.0, 0.0);

            for (int i = 0; i < sample_count; ++i) {
                vector3 light_sample = sample_area_light(light);
                vector3 light_dir = (light_sample - point).unit();
                vector3 half_vector = (view_dir + light_dir).unit();

                // Diffuse contribution
                double diff = std::max(0.0, normal.dot(light_dir));
                vector3 diffuse = material.kd * diff * texture_color * light.intensity;

                // Specular contribution
                double spec = std::pow(std::max(0.0, normal.dot(half_vector)), material.specularexponent);
                vector3 specular = material.ks * spec * material.specularcolor * light.intensity;

                // Shadow factor
                double shadow_factor = compute_shadow_factor(point, light_sample);

                // Accumulate sample contribution
                light_contribution += (diffuse + specular) * shadow_factor;
            }

            // Average over all samples
            color += light_contribution / static_cast<double>(sample_count);
        }
    }

    return color;
}
